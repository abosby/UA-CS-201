BQueue<Node> queue = new BQueue<Node>();
		BQueue<Node> eQueue = new BQueue<Node>();
		DoublyLinkedList sEdge = new DoublyLinkedList();
		Node nRoot = front;
		//Find Root
		while(nRoot.value.getValue() != root){
			nRoot = nRoot.next;
		}
		Node temp = null;
		Node prev = nRoot;
		queue.enqueue(nRoot);
		System.out.printf("0: %d;\n",root);
		int v = 1;
		while(true){
			System.out.printf("%d: ",v);
			while(queue.getSize() != 0){
				prev = temp;
				temp = queue.dequeue();
				Node tNode = front;
				while(tNode != null){
					//If temp is the parent
					if(tNode.parent.value == temp.value){
						tNode.level = temp.level++;
						//queue.enqueue(tNode);
						eQueue.enqueue(tNode);
					}
					//If temp is the child

					else if(temp.parent.value == tNode.value){
						//if((temp.parent.value != nRoot.value) && (tNode.value != nRoot.value)){
						//if(eList.getEdge(tNode.value,temp.parent.value) != null){
						tNode.level = temp.level++;
						tNode.child = temp;
						//Reset children
						Node tTNode = tNode;
						Node tempNode = temp;
						Node advanceNode = tNode;
						while(tTNode.parent != advanceNode){
							advanceNode = tTNode.parent;
							tTNode.parent = tempNode;
							tempNode = tTNode;
							tTNode = advanceNode;
						}
						//queue.enqueue(tNode);
						eQueue.enqueue(tNode);
					}
					tNode = tNode.next;
				}
			}
			//Pass next level edges from eQueue to the queue
			Node temp2;
			Edge fEdge;
			while(eQueue.getSize() != 0){
				temp2 = eQueue.dequeue();
				fEdge = eList.removeEdge(temp2.value,temp2.parent.value);
				//fEdge = eList.getEdge(temp2.value, temp.value);
				if(fEdge != null){
					queue.enqueue(temp2);
					sEdge.addItem(fEdge);
				}
			}
			sEdge.mergeSort(sEdge.getFront());
			Edge tempPointer;
			while(sEdge.getSize() != 0){
				tempPointer = sEdge.removeItem();
				System.out.printf("%d(%d)%d; ",tempPointer.getVertex2().getValue(),tempPointer.getVertex1().getValue(),tempPointer.getWeight());
			}
			System.out.println("");
			v++;
		}
	}
	
			/**
		String filePath= new File(fileArg).getAbsolutePath();
		BufferedReader br = null;
		BQueue<String> descriptionQueue= new BQueue<String>();
		String line;
		try {
			br = new BufferedReader(new FileReader(filePath));
			while((line = br.readLine()) != null){
				//while(sc.hasNextLine()){
				//sc = new Scanner(new File(filePath));
				/**
				Scanner sc2 = new Scanner(sc.nextLine());
				while(sc2.hasNext()){
					descriptionQueue.enqueue(sc2.next());
				}
				String[] tokens = line.split(" ");
				for (String token : tokens){
					if(!token.equals("")){
						descriptionQueue.enqueue(token);
					}
				}
			}
		} catch (FileNotFoundException e) {
			System.out.println("Corpus File not found");
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		 */

		/**
			while(descriptionQueue.getSize()!=0){
				String vertex1 = descriptionQueue.dequeue();
				String vertex2 = descriptionQueue.dequeue();
				String weight= descriptionQueue.dequeue();
				if(!VerticesList.contains(Integer.valueOf(vertex1))){
					VerticesList.add(Integer.valueOf(vertex1));
				}
				if(!VerticesList.contains(Integer.valueOf(vertex2))){
					VerticesList.add(Integer.valueOf(vertex2));
				}
				if(weight.equals(";")){
					Edge e = new Edge(vertex1, vertex2);
					EList.add(e);
				}
				else{
					Edge e = new Edge(vertex1, vertex2, Integer.valueOf(weight));
					EList.add(e);
					@SuppressWarnings("unused")
					String semiColon = descriptionQueue.dequeue();
				}
			}
		*/